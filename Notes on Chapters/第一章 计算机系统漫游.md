### 1.大部分现代计算机系统用来表示文本字符的标准是什么，这种方式的实质是什么？举例说明。文本文件和二进制文件各自的定义又是什么？P2
ACSII码。实质是用一个唯一的单字节整数表示每一个字符。如下图中程序

<img src="https://i.loli.net/2017/09/15/59bb970178e6c.png" width="500">
用ASCII码表示如下：

<img src="https://i.loli.net/2017/09/15/59bb983a932b1.png" width="500"> 
只由ASCII码构成的文件称为文本文件，所有其它文件都称为二进制文件。

### 2.C语言是由谁创建的，最初目的是什么？它的应用场景如何？ P2-3
C语言是由贝尔实验室的Dennis Ritchie为了实现Unix操作系统而实现的。大部分Unix的内核及所有支撑工具和函数库都是用C编写的。

C语言是系统级编程的首选，同时也非常适用于应用级程序的编写。但它的指针容易造成程序员的困惑和错误，且它缺乏对抽象的显式支持，如类、对象和异常。这些问题由针对应用级程序的新语言C++和Java等解决。

### 3.概述一个hello程序的生命周期。 P3
hello.c程序中的每条c语句都会被其他程序转化成一系列的低级机器语言指令，这些指令按照一种称为可执行目标程序的格式打包，以二进制磁盘文件的形式存放起来。

### 4.以hello.c为例，描述编译系统如何将源文件转化为目标文件。 P3-4
在Unix系统上，由源文件到目标文件的转化由编译器驱动程序(compiler driver)完成：

`linux> gcc -o hello hello.c`

此处GCC编译器驱动程序将读取源程序文件hello.c，并分四个阶段把它翻译成一个可执行目标文件hello。执行这四个阶段的程序为别为预处理器、编译器、汇编器和链接器，他们共同组成了编译系统(compilation system)。

![Alt text](/Images/1-3-compilation-system.PNG)

- 预处理阶段：预处理器cpp先根据以字符#开头的命令修改原始C程序。如在hello.c中，cpp根据`#include<studio.h>`命令读取系统头文件`studio.h`中的内容，并将它直接插入程序文本中。预处理的结果是得到一个另一个以.i作为扩展名的C程序。
- 编译阶段：编译器ccl将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含`main`函数的定义。(注：书上与Ubuntu17.04使用`gcc -S hello.c`命令运行出来的结果不同，见本文尾部附录）
.s文件中的每一条语句都描述了一条低级机器语言指令。汇编语言为不同高级语言的不同编译器提供了通用的输出语言。如C编译器和Fortran的编译器产生的输出文件用的是一样的汇编语言。
- 汇编阶段：汇编器as将hello.s翻译成机器语言指令，把这些指令打包成*可重定位目标程序* (relocatable object program)。


### 5.简述GNU项目。P4


### 笔记：
- A compiler driver is a program which invokes the other　components of the tool set to process a program. There is a　separate compiler driver for each source language. The drivers　use command line arguments and source file extensions to　determine which compiler or assembler to invoke for each　source file, then sequence the resulting output through the　subsequent linker and conversion utilities, relieving the user of　the burden of invoking each of these tools individually.
- Object program: a computer program translated from the equivalent source program into machine language by the compiler or assembler
- What exactly causes binary file “gibberish”?
	- The binary values of the file are tried to be converted into ASCII by typical text editors. Typically, the binary values of the file also include ASCII control characters that aren't printable, resulting in even more bizarre display in a typical text editor.
	- What you want is a "hex editor", rather than a normal text editor. This will show you the raw contents of the file (typically in hexadecimal rather than binary, since the zeros and ones would take up a lot of space and be harder to read).
	- There is a Linux command-line program called "file" that will attempt to analyze the file (typically looking for common header patterns) and tell you what sort of file it is (for example text, or audio, or video, or XML, etc). 
	  <img src="/Images/file-tool-linux.PNG" width="900"> 

### 附录：`hello.s`
//书上的例子
```
main:
	subq	$8, %rsp
	movl	$.LCO, %edi
	call	puts
	movl	$0, %eax
	addq	$8, %rsp
	ret
```
//Ubuntu17.04运行结果
```
	.file	"hello.c"
	.section	.rodata
.LC0:
	.string	"hello, world!"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 6.3.0-12ubuntu2) 6.3.0 20170406"
	.section	.note.GNU-stack,"",@progbits
```
