### 1.大部分现代计算机系统用来表示文本字符的标准是什么，这种方式的实质是什么？举例说明。文本文件和二进制文件各自的定义又是什么？P2
ACSII码。实质是用一个唯一的单字节整数表示每一个字符。如下图中程序

<img src="https://i.loli.net/2017/09/15/59bb970178e6c.png" width="500">
用ASCII码表示如下：

<img src="https://i.loli.net/2017/09/15/59bb983a932b1.png" width="500"> 
只由ASCII码构成的文件称为文本文件，所有其它文件都称为二进制文件。

### 2.C语言是由谁创建的，最初目的是什么？它的应用场景如何？ P2-3
C语言是由贝尔实验室的Dennis Ritchie为了实现Unix操作系统而实现的。大部分Unix的内核及所有支撑工具和函数库都是用C编写的。

C语言是系统级编程的首选，同时也非常适用于应用级程序的编写。但它的指针容易造成程序员的困惑和错误，且它缺乏对抽象的显式支持，如类、对象和异常。这些问题由针对应用级程序的新语言C++和Java等解决。

### 3.概述一个hello程序的生命周期。 P3
hello.c程序中的每条c语句都会被其他程序转化成一系列的低级机器语言指令，这些指令按照一种称为可执行目标程序的格式打包，以二进制磁盘文件的形式存放起来。

### 4.以hello.c为例，描述编译系统如何将源文件转化为目标文件。 P3-4
在Unix系统上，由源文件到目标文件的转化由编译器驱动程序(compiler driver)完成：

`linux> gcc -o hello hello.c`

此处GCC编译器驱动程序将读取源程序文件hello.c，并分四个阶段把它翻译成一个可执行目标文件hello。执行这四个阶段的程序为别为预处理器、编译器、汇编器和链接器，他们共同组成了编译系统(compilation system)。

![Alt text](/Images/1-3-compilation-system.PNG)

- 预处理阶段：预处理器cpp先根据以字符#开头的命令修改原始C程序。如在hello.c中，cpp根据`#include<studio.h>`命令读取系统头文件`studio.h`中的内容，并将它直接插入程序文本中。预处理的结果是得到一个另一个以.i作为扩展名的C程序。
- 编译阶段：编译器ccl将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。该程序包含`main`函数的定义。(注：书上与Ubuntu17.04使用`gcc -S hello.c`命令运行出来的结果不同，见本文尾部附录）
.s文件中的每一条语句都描述了一条低级机器语言指令。汇编语言为不同高级语言的不同编译器提供了通用的输出语言。如C编译器和Fortran的编译器产生的输出文件用的是一样的汇编语言。
- 汇编阶段：汇编器as将hello.s翻译成机器语言指令，把这些指令打包成*可重定位目标程序* (relocatable object program)`hello.o`。该程序如果在文本编辑器中打开，会出现一堆乱码。
- 链接阶段：hello程序调用的`printf`函数是每个C编译器都提供的，*标准C库*中的一个函数，它存在于一个预编译好了的单独的目标文件`printf.o`中。链接器ld负责将这个文件以某种方式合并到`hello.o`程序中，得到*可执行目标文件*`hello`，它可以被加载到内存中由系统执行。


### 5.简述GNU项目。P4
GNU是GNU's Not Unix项目的简称，该项目的宗旨是开发一个类Unix的系统，该系统的源码能够不受限制地修改和传播。GNU项目已经开发出了一个包含Unix操作系统的主要部件的环境，但Linux内核除外（Linux内核是由Linux项目独立发展而来的）。GNU环境包括EMACS编辑器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具等。

在很大程度上，由于GNU为Linux内核提供了环境，Linux才能如此受欢迎。另外，常与Linux联系在一起的现代开放源码运动 (the modern opensource movement) 也起源于GNU项目中free software的概念。（注：free-自由 as in "free speech", not "free beer")

###  6.简述计算机的硬件组成。 

#### 6.1 I/O总线上controller和adapter的区别

#### 6.2 processor的instruction set architecture和microarchitecture的区别

###  7.简述运行hello程序时数据在计算机硬件架构中的流动。

###  8.如何理解操作系统在软硬件之间的角色?

###  9.简述Unix出现的历史和Posix。

###  10.简述操作系统提供的三层抽象。

###  11. 简述Linux系统的出现。

###  12. 简述用telnet在远程计算机上运行hello程序时发生了什么。

### 13.简述计算机中从上到下三层concurrency抽象。（要重看）



### 笔记：
1. A compiler driver is a program which invokes the other components of the tool set to process a program. There is a separate compiler driver for each source language. The drivers　use command line arguments and source file extensions to determine which compiler or assembler to invoke for each　source file, then sequence the resulting output through the subsequent linker and conversion utilities, relieving the user of the burden of invoking each of these tools individually.
2. Object program: a computer program translated from the equivalent source program into machine language by the compiler or assembler
3. What exactly causes binary file “gibberish”?
	- The binary values of the file are tried to be converted into ASCII by typical text editors. Typically, the binary values of the file also include ASCII control characters that aren't printable, resulting in even more bizarre display in a typical text editor.
	- What you want is a "hex editor", rather than a normal text editor. This will show you the raw contents of the file (typically in hexadecimal rather than binary, since the zeros and ones would take up a lot of space and be harder to read).
	- There is a Linux command-line program called "file" that will attempt to analyze the file (typically looking for common header patterns) and tell you what sort of file it is (for example text, or audio, or video, or XML, etc). 
	  <img src="/Images/file-tool-linux.PNG" width="900"> 
4. Unix和Linux的区别：
	- **Linux is a UNIX Clone.** If you consider Portable Operating System Interface (POSIX) standards then Linux can be considered as UNIX. To quote from Official Linux kernel README file:
	```
	Linux is a Unix clone written from scratch by Linus Torvalds with assistance from a loosely-knit team of hackers across the Net. 
	It aims towards POSIX compliance.
	```
	However, “Open Group” do not approve of the construction “Unix-like”, and consider it misuse of their UNIX trademark.
	- **Linux Is Just a Kernel.** Linux is just a kernel. All Linux distributions includes GUI system + GNU utilities (such as cp, mv, ls,date, bash etc) + installation & management tools + GNU c/c++ Compilers + Editors (vi) + and various applications (such as OpenOffice, Firefox). However, most UNIX operating systems are considered as a complete operating system as everything come from a single source or vendor.
	- **License and cost:** Linux is Free (as in beer [freedom]). You can download it from the Internet or redistribute it under GNU licenses. You will see the best community support for Linux. Most UNIX like operating systems are not free (but this is changing fast, for example OpenSolaris UNIX).
	- **User-Friendly:** Linux is considered as most user friendly UNIX like operating systems. It makes it easy to install sound card, flash players, and other desktop goodies. However, Apple OS X is most popular UNIX operating system for desktop usage.
	- **File Systems:**
		- Linux by default supports and use ext3 or ext4 file systems.
		- UNIX comes with various file systems such as jfs, gpfs (AIX), jfs, gpfs (HP-UX), jfs, gpfs (Solaris).
	- **UNIX Operating System Names：**
		
		A few popular names:
		- HP-UX
		- IBM AIX
		- Sun Solairs
		- Mac OS X
		- IRIX
	- **Linux Distribution (Operating System) Names：**
		
		A few popular names:
		- Redhat Enterprise Linux
		- Fedora Linux
		- Debian Linux
		- Suse Enterprise Linux
		- Ubuntu Linux
	- **Common Things Between Linux & UNIX:**
		
		Both share many common applications such as:
		- GUI, file, and windows managers (KDE, Gnome)
		- Shells (ksh, csh, bash)
		- Various office applications such as OpenOffice.org
		- Development tools (perl, php, python, GNU c/c++ compilers)
		- Posix interface
5. Why is Open Source software important?

	Open source software is doing something very similar to what science has been doing over the past couple hundred years.  General science - research done into physics, biology, mathematics, etc - is done in an environment of peer review.  That means that science by its very nature is (mostly) open source; you have to share your science with other people so that they can evaluate it.  When it's agreed to be solid, everyone can use that knowledge to keep advancing.

	OS isn't perfectly analogous, but it has a lot in common.  Tools are being created and shared so that more tools can be created.  Sometimes you can take an existing tool that doesn't quite do what you want and modify it so that it's what you need.  Sometimes you can take several other tools and combine them to create something new.  The more this is done in an open environment, the more powerful tools we can create.
	
6. 阅读 

	[关于RAM](关于RAM.md)

		在计算机的组成结构中，有一个很重要的部分，就是存储器。存储器是用来存储程序和数据的部件，对于计算机来说，有了存储器，才有记忆功能，才能保证正常工作。存储器的种类很多，按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存，港台称之为记忆体）。
	
	内存又称主存，是CPU能直接寻址的存储空间，由半导体器件制成。内存的特点是存取速率快。内存是电脑中的主要部件，它是相对于外存而言的。我们平常使用的程序，如Windows操作系统、打字软件、游戏软件等，一般都是安装在硬盘等外存上的。但仅此是不能使用其功能的，必须把它们调入内存中运行，才能真正使用其功能，我们平时输入一段文字，或玩一个游戏，其实都是在内存中进行的。就好比在一个书房里，存放书籍的书架和书柜相当于电脑的外存，而我们工作的办公桌就是内存。通常我们把要永久保存的、大量的数据存储在外存上，而把一些临时的或少量的数据和程序放在内存上，当然内存的好坏会直接影响电脑的运行速度。
	
	In early 2012, a new Mac might be equipped with 4 GB of memory and a hard drive whose storage capacity is 500 GB. The primary reason for this great disparity is cost. Memory, RAM, is much more expensive then hard drive storage space. Here’s a rough comparison. One GB of RAM costs about $8, while 1 GB of hard drive storage space costs about 10 cents. In other words, RAM costs about 8000 as much as hard drive storage space.
	
	Oddly enough, memory does not "remember" anything when the power is turned off. So why do they call it memory? Because the first memory did "remember," but today's RAM chips do not. Although there are memory chips that do hold their content permanently (ROMs, EEPROMs, flash memory, etc.), they are used for internal control purposes and data storage, not for processing. 

### 附录：`hello.s`
- 书上的例子
```
main:
	subq	$8, %rsp
	movl	$.LCO, %edi
	call	puts
	movl	$0, %eax
	addq	$8, %rsp
	ret
```
- Ubuntu17.04运行结果
```
	.file	"hello.c"
	.section	.rodata
.LC0:
	.string	"hello, world!"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 6.3.0-12ubuntu2) 6.3.0 20170406"
	.section	.note.GNU-stack,"",@progbits
```
